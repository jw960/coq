(************************************************************************)
(*  v      *   The Coq Proof Assistant  /  The Coq Development Team     *)
(* <O___,, *   INRIA - CNRS - LIX - LRI - PPS - Copyright 1999-2016     *)
(*   \VV/  **************************************************************)
(*    //   *      This file is distributed under the terms of the       *)
(*         *       GNU Lesser General Public License Version 2.1        *)
(************************************************************************)

(* TODO

  - make interpretation output constr_expr
  - take care of prims
 *)

(** Notation interpretation pass. Split from constrintern by EJGA.

    Coq supports an advanced, user-friendly notation system that can
    be used to modify the syntax of the language in varied ways.

    When a notation is declared, a new parsing rule is added to the
    global grammar by `Egramcoq.make_act`. This function will extend the
    entries `Pcoq.Constr.operconstr` and `Pcoq.Constr.pattern` entries
    to enable term and pattern parsing of new constructors, althought
    there is no technical reason why other entries couldn't be extended
    too.

    The parsing actions attached to the extension points are quite
    rigid. In the first case, the rule, if triggered, will return a
    `CNotation` term, whereas for patterns, we will have a freshly
    parsed `CPatNotation` element of type `cases_pattern_expr`.

    The mission of this file is to "unfold" all the terms generated by
    the notation system, substituting the proper term in its place.

    This process, "notation interpretation", selects the proper term
    to resolve the pattern to, using a "scope" system, and ensures
    that all passes after it don't have to worry about notations
    anymore.

    In the original design, notation interpretation happened
    simultaneously with the so-called internalization. This process is
    also in charge of resolving references, implicit arguments, and
    global references, and often the interaction between all these
    four features are subtle. The resulting "internalized" term, of
    type `glob_constr`, conforms the core untyped syntax of the Coq
    system.

    The richness of the above interactions, tied with the intricancy
    of advanced features such as recursive notations, made reasoning
    about the system not trivial.

    Moreover, a term of type `glob_constr` has become too detached
    from the syntax, making it difficult to accurately map to the
    user's buffer. Such mappings are desirable for instance to provide
    essential features in a modern UI such as "disable notation on
    hover".

    In constrast with the old approach, this file implements notation
    interpretation as an AST transformation. That is to say, we won't
    return an elaborated `glob_constr`, but we will however proceed to
    replace syntax by syntax, leaving the rest of the job to a later
    pass.

    Before we go on, we must mention a couple of additional tasks
    performed by notation interpretation. First, notation
    interpretation has to take care of resolving "syntactic
    extensions", a legacy form of notations which works a bit
    differently. Unfortunately, this introduces some degree of
    non-unformity in the code. Second, the notation system is in
    charge of mapping numerals and string constants, called
    "primitives" terms by Coq and encoded using the `CPrim`
    constructor. This is fairly straightforward thou a few special
    cases are needed. And last, but not least, record notation must be
    replaced by the record constructor; while record notation is not
    user overridable, it shares the same substitution scheme than the
    rest of the notations, so it makes sense to resolve it in the
    notation pass.

    With these preliminaries in mind, we proceed to describe the
    notation interpretation process in some detail.

    `Notation.interp_notation` is the main function resolving a
    notation, usually a string of the form "_ + _", to a notation
    term, in this case something of the form `NApp (NRef Nat.Plus)
    (NVar 'x') (NVar 'y')`, plus some information about the scope of
    the variables (XXX: why is this not attached to the variables
    themselves?)

    Now we focus on patterns. There is great news here, basically all
    of the job for patterns was done for us in
    b2953849b999d1c3b42c0f494b234f2a93ac7754, cool!

    Indeed,

    ```
    val drop_notations_pattern :
    inductive_pattern:bool ->
    Notation.local_scopes ->
    Constrexpr.cases_pattern_expr ->
    raw_cases_pattern_expr
    ```

    will take a pattern and resolve the CPatNotation constructor. It
    has some safeguard [XXX define].

    The algorithm proceeds as follows:

    - CPatAlias: transformed verbatim.

    - CPatRecord: resolved normaly to a notation-free pattern, with
      special, complex treatment when the head symbol is a syndef.

    - CPatCstr: we first process differently `(@r ...) ...` patterns
      from non explicit ones. For non explicit ones, we do standard
      syndef processing. For explicit ones, there is some deactivation
      of implicits arguments an scopes going on, with the special case
      of using `(@r)`.

    - CPatNotation: after some preprocessing related to the "{ _ }"
      notation, we resolve the notation using `interp_notation`. The
      second step splits the variables present in the notation to
      single out variables that are supposed to contain a list in
      recursive notations. Variables of type `NtnTypeBinderList` are
      ignored by pattern interpretation.

      make_subst

    - CPatDelimiters

    - CPatPrim

    - CPatAtom

    - CPatOr

    - CPatCast
*)

open Names
open Libnames
open Globnames
open Notation_term
open Notation_ops
open Constrexpr
open Constrexpr_ops

(* START Duplicated with constrintern *)

let error_not_enough_arguments loc =
  CErrors.user_err ~loc Pp.(str "Abbreviation is not applied enough.")

let locate_reference qid =
  Smartlocate.global_of_extended_global (Nametab.locate_extended qid)

let global_reference_of_reference ref =
  locate_reference (snd (qualid_of_reference ref))

(* END   Duplicated with constrintern *)

(** Unfolding of record notation *)
let check_duplicate loc fields =
  let eq (ref1, _) (ref2, _) = eq_reference ref1 ref2 in
  let dups = CList.duplicates eq fields in
  match dups with
  | [] -> ()
  | (r, _) :: _ ->
    CErrors.user_err ~loc Pp.(str "This record defines several times the field " ++
      pr_reference r ++ str ".")

(** [sort_fields ~complete loc fields completer] expects a list
    [fields] of field assignments [f = e1; g = e2; ...], where [f, g]
    are fields of a record and [e1] are "values" (either terms, when
    interning a record construction, or patterns, when intering record
    pattern-matching). It will sort the fields according to the record
    declaration order (which is important when type-checking them in
    presence of dependencies between fields). If the parameter
    [complete] is true, we require the assignment to be complete: all
    the fields of the record must be present in the
    assignment. Otherwise the record assignment may be partial
    (in a pattern, we may match on some fields only), and we call the
    function [completer] to fill the missing fields; the returned
    field assignment list is always complete. *)
let sort_fields ~complete loc fields completer =
  match fields with
    | [] -> None
    | (first_field_ref, first_field_value):: other_fields ->
        let (first_field_glob_ref, record) =
          try
            let gr = global_reference_of_reference first_field_ref in
            (gr, Recordops.find_projection gr)
          with Not_found ->
            CErrors.user_err ~loc:(loc_of_reference first_field_ref) ~hdr:"intern"
              Pp.(pr_reference first_field_ref ++ str": Not a projection")
        in
        (* the number of parameters *)
        let nparams = record.Recordops.s_EXPECTEDPARAM in
        (* the reference constructor of the record *)
        let base_constructor =
          let global_record_id = ConstructRef record.Recordops.s_CONST in
          try Qualid (loc, Nametab.shortest_qualid_of_global Id.Set.empty global_record_id)
          with Not_found ->
            CErrors.anomaly Pp.(str "Environment corruption for records") in
        let () = check_duplicate loc fields in
        let (end_index,    (* one past the last field index *)
             first_field_index,  (* index of the first field of the record *)
             proj_list)    (* list of projections *)
          =
          (* elimitate the first field from the projections,
             but keep its index *)
          let rec build_proj_list projs proj_kinds idx ~acc_first_idx acc =
            match projs with
              | [] -> (idx, acc_first_idx, acc)
              | (Some name) :: projs ->
                 let field_glob_ref = ConstRef name in
                 let first_field = eq_gr field_glob_ref first_field_glob_ref in
                 begin match proj_kinds with
                    | [] -> CErrors.anomaly Pp.(str "Number of projections mismatch")
                    | (_, regular) :: proj_kinds ->
                       (* "regular" is false when the field is defined
                           by a let-in in the record declaration
                           (its value is fixed from other fields). *)
                       if first_field && not regular && complete then
                         CErrors.user_err ~loc Pp.(str "No local fields allowed in a record construction.")
                       else if first_field then
                         build_proj_list projs proj_kinds (idx+1) ~acc_first_idx:idx acc
                       else if not regular && complete then
                         (* skip non-regular fields *)
                         build_proj_list projs proj_kinds idx ~acc_first_idx acc
                       else
                         build_proj_list projs proj_kinds (idx+1) ~acc_first_idx
                                         ((idx, field_glob_ref) :: acc)
                 end
              | None :: projs ->
                 if complete then
                   (* we don't want anonymous fields *)
                   CErrors.user_err ~loc Pp.(str "This record contains anonymous fields.")
                 else
                   (* anonymous arguments don't appear in proj_kinds *)
                   build_proj_list projs proj_kinds (idx+1) ~acc_first_idx acc
          in
          build_proj_list record.Recordops.s_PROJ record.Recordops.s_PROJKIND 1 ~acc_first_idx:0 []
        in
        (* now we want to have all fields assignments indexed by their place in
           the constructor *)
        let rec index_fields fields remaining_projs acc =
          match fields with
            | (field_ref, field_value) :: fields ->
               let field_glob_ref = try global_reference_of_reference field_ref
               with Not_found ->
                 CErrors.user_err ~loc:(loc_of_reference field_ref) ~hdr:"intern"
                               Pp.(str "The field \"" ++ pr_reference field_ref ++ str "\" does not exist.") in
               let remaining_projs, (field_index, _) =
                 let the_proj (idx, glob_ref) = eq_gr field_glob_ref glob_ref in
                 try CList.extract_first the_proj remaining_projs
                 with Not_found ->
                   CErrors.user_err ~loc
                     Pp.(str "This record contains fields of different records.")
               in
               index_fields fields remaining_projs ((field_index, field_value) :: acc)
            | [] ->
               (* the order does not matter as we sort them next,
                  List.rev_* is just for efficiency *)
               let remaining_fields =
                 let complete_field (idx, _field_ref) = (idx, completer idx) in
                 List.rev_map complete_field remaining_projs in
               List.rev_append remaining_fields acc
        in
        let unsorted_indexed_fields =
          index_fields other_fields proj_list
            [(first_field_index, first_field_value)] in
        let sorted_indexed_fields =
          let cmp_by_index (i, _) (j, _) = Int.compare i j in
          List.sort cmp_by_index unsorted_indexed_fields in
        let sorted_fields = List.map snd sorted_indexed_fields in
        Some (nparams, base_constructor, sorted_fields)

type raw_cases_pattern_expr =
  | RCPatAlias  of Loc.t * raw_cases_pattern_expr * Id.t
  | RCPatCstr   of Loc.t * Globnames.global_reference
    * raw_cases_pattern_expr list * raw_cases_pattern_expr list
  (** [CPatCstr (_, c, l1, l2)] represents ((@c l1) l2) *)
  | RCPatAtom   of Loc.t * Id.t option
  | RCPatOr     of Loc.t * raw_cases_pattern_expr list

let raw_cases_pattern_expr_loc = function
  | RCPatAlias (loc,_,_) -> loc
  | RCPatCstr (loc,_,_,_) -> loc
  | RCPatAtom (loc,_) -> loc
  | RCPatOr (loc,_) -> loc

type notation_resolution_error =
  | NotAConstructor of reference

exception NotationResolutionError of Loc.t * notation_resolution_error

let explain_not_a_constructor ref =
  Pp.(str "Unknown constructor: " ++ pr_reference ref)

let explain_notation_resolution_error e =
  let pp = match e with
    | NotAConstructor ref -> explain_not_a_constructor ref
  in Pp.(pp ++ str ".")

let error_bad_inductive_type ?loc =
  CErrors.user_err ?loc Pp.(str
    "This should be an inductive type applied to patterns.")

(* Auxiliary functions *)
let find_pattern_variable = function
  | Ident (loc,id) -> id
  | Qualid (loc,_) as x -> raise (NotationResolutionError(loc,NotAConstructor x))

let rec subst_pat_iterator y t p = match p with
  | RCPatAtom (_,id) ->
    begin match id with Some x when Id.equal x y -> t | _ -> p end
  | RCPatCstr (loc,id,l1,l2) ->
    RCPatCstr (loc,id,List.map (subst_pat_iterator y t) l1,
 	       List.map (subst_pat_iterator y t) l2)
  | RCPatAlias (l,p,a) -> RCPatAlias (l,subst_pat_iterator y t p,a)
  | RCPatOr (l,pl) -> RCPatOr (l,List.map (subst_pat_iterator y t) pl)

(**********************************************************************)
(* Contracting "{ _ }" in notations                                   *)
(* XXX: Document better                                               *)
(**********************************************************************)
let rec wildcards ntn n =
  if Int.equal n (String.length ntn) then []
  else let l = spaces ntn (n+1) in if ntn.[n] == '_' then n::l else l
and spaces ntn n =
  if Int.equal n (String.length ntn) then []
  else if ntn.[n] == ' ' then wildcards ntn (n+1) else spaces ntn (n+1)

let expand_notation_string ntn n =
  let pos = List.nth (wildcards ntn 0) n in
  let hd = if Int.equal pos 0 then "" else String.sub ntn 0 pos in
  let tl =
    if Int.equal pos (String.length ntn) then ""
    else String.sub ntn (pos+1) (String.length ntn - pos -1) in
  hd ^ "{ _ }" ^ tl

let contract_pat_notation ntn (l,ll) =
  let ntn' = ref ntn in
  let rec contract_squash n = function
    | [] -> []
    | CPatNotation (_,"{ _ }",([a],[]),[]) :: l ->
        ntn' := expand_notation_string !ntn' n;
        contract_squash n (a::l)
    | a :: l ->
        a::contract_squash (n+1) l in
  let l = contract_squash 0 l in
  (* side effect; don't inline *)
  !ntn',(l,ll)

(* This contracts the special case of "{ _ }" for sumbool, sumor notations *)
(* Remark: expansion of squash at definition is done in metasyntax.ml *)
let contract_notation ntn (l,ll,bll) =
  let ntn' = ref ntn in
  let rec contract_squash n = function
    | [] -> []
    | CNotation (_,"{ _ }",([a],[],[])) :: l ->
        ntn' := expand_notation_string !ntn' n;
        contract_squash n (a::l)
    | a :: l ->
        a::contract_squash (n+1) l in
  let l = contract_squash 0 l in
  (* side effect; don't inline *)
  !ntn',(l,ll,bll)


(** { 5 Notation Expansion in terms *)

(**********************************************************************)
(* Syntax extensions                                                  *)

let option_mem_assoc id = function
  | Some (id',c) -> Id.equal id id'
  | None -> false

let find_fresh_name renaming (terms,termlists,binders) avoid id =
  let fold1 _ (c, _) accu = Id.Set.union (Topconstr.free_vars_of_constr_expr c) accu in
  let fold2 _ (l, _) accu =
    let fold accu c = Id.Set.union (Topconstr.free_vars_of_constr_expr c) accu in
    List.fold_left fold accu l
  in
  let fold3 _ x accu = Id.Set.add x accu in
  let fvs1 = Id.Map.fold fold1 terms avoid in
  let fvs2 = Id.Map.fold fold2 termlists fvs1 in
  let fvs3 = Id.Map.fold fold3 renaming fvs2 in
  (* TODO binders *)
  Namegen.next_ident_away_from id (fun id -> Id.Set.mem id fvs3)


type not_var_internalization_data =
    Notation_term.scope_name option list (** subscopes of the args of the variable *)

(** A map of free variables to their scopes *)
type not_internalization_env = not_var_internalization_data Id.Map.t

type intern_env = {
  ids: Names.Id.Set.t;
  unb: bool;
  tmp_scope: Notation_term.tmp_scope_name option;
  scopes: Notation_term.scope_name list;
  impls: not_internalization_env }

let traverse_binder (terms,_,_ as subst) avoid (renaming,env) = function
 | Anonymous -> (renaming,env),Anonymous
 | Name id ->
  try
    (* Binders bound in the notation are considered first-order objects *)
    let _,na = coerce_to_name (fst (Id.Map.find id terms)) in
    (renaming,{ env with ids = Nameops.name_fold Id.Set.add na env.ids }), na
  with Not_found ->
    (* Binders not bound in the notation do not capture variables *)
    (* outside the notation (i.e. in the substitution) *)
    let id' = find_fresh_name renaming subst avoid id in
    let renaming' =
      if Id.equal id id' then renaming else Id.Map.add id id' renaming
    in
    (renaming',env), Name id'

type letin_param =
  | LPLetIn of Loc.t * (Name.t * constr_expr * constr_expr option)
  | LPCases of Loc.t * (cases_pattern_expr * Id.t list) * Id.t

let make_letins =
  List.fold_right
    (fun a c ->
     match a with
     | LPLetIn (loc,(na,b,t)) ->
         CLetIn(loc,(loc,na),b,t,c)
     | LPCases (loc,(cp,il),id) ->
         let tt = (CRef(Libnames.Ident(loc,id),None),Some (loc,Name id),None) in
         (* XXX Note the original.... *)
         CCases(loc,Misctypes.LetPatternStyle,None,[tt],[(loc,[(loc,[cp])],c)]))

let rec subordinate_letins letins = function
  (* binders come in reverse order; the non-let are returned in reverse order together *)
  (* with the subordinated let-in in writing order *)
  | CLocalDef ((loc,na),b,t)::l ->
      subordinate_letins (LPLetIn (loc,(na,b,t))::letins) l
  | CLocalAssum (nal,bk,t)::l ->
      let letins',rest = subordinate_letins [] l in
      letins',(((nal,bk,t)),letins)::rest
  | CLocalPattern (loc,cp,t) :: l ->
    let id = Id.of_string "XXX" in
      subordinate_letins (LPCases (loc,(cp,[]),id)::letins) l
        (* ([CLocalAssum ([loc,Name id])] @ l) *)
  | [] -> letins,[]

let terms_of_binders bl =
  let term_of_pat = function
    | CPatAlias (loc,_,id) -> CRef (Ident (loc,id), None)
    | _ -> CErrors.user_err Pp.(str "fixme")
  in
  let rec extract_variables = function
    | CLocalAssum ([loc,Name id],_,_)::l -> CRef (Ident (loc,id), None) :: extract_variables l
    | CLocalDef ((loc,Name id),_,_)::l -> extract_variables l
    | CLocalDef ((loc,Anonymous),_,_)::l
    | CLocalAssum ([loc,Anonymous],_,_)::l -> CErrors.error "Cannot turn \"_\" into a term."
    | CLocalPattern (loc,u,_) :: l -> term_of_pat u :: extract_variables l
    | [] -> []
    | _ -> CErrors.user_err Pp.(str "fixme")
  in
  extract_variables bl

(******************************************************************************)
(* Duplicated XXX                                                             *)
(******************************************************************************)
let set_type_scope env = {env with tmp_scope = Notation.current_type_scope_name ()}

exception NotVariableCapture of Loc.t * Id.t * Id.t

let rec check_capture ty = function
  (* XXXXXXXX *)
  (* | (loc,Name id)::(_,Name id')::_ when Glob_ops.occur_glob_constr id ty -> *)
  (*   raise (NotVariableCapture (loc,id,id')) *)
  | (loc,Name id)::(_,Name id')::_ ->
    raise (NotVariableCapture (loc,id,id'))
  | _::nal ->
    check_capture ty nal
  | [] -> ()

let build_impls = function
  | Decl_kinds.Implicit -> (function
		  |Name id ->  Some (id, Impargs.Manual, (true,true))
		  |Anonymous -> Some (Id.of_string "_", Impargs.Manual, (true,true)))
  | Decl_kinds.Explicit -> fun _ -> None

type ___u01 = Variable | Inductive of Id.t list

let impls_type_list ?(args = []) _ = []
let impls_term_list ?(args = []) _ = []

let locate_if_hole loc na = function
  | CHole (_,_,naming,arg) ->
    (try match na with
       | Name id ->
         (* XXX *)
         let trm = glob_constr_of_notation_constr loc (Reserve.find_reserved_type id) in
         Constrextern.extern_glob_constr Names.Id.Set.empty trm
       | Anonymous -> raise Not_found
      with Not_found -> CHole (loc, Some (Evar_kinds.BinderType na), naming, arg))
  | x -> x

let error_ldots_var ?loc =
  CErrors.user_err ?loc Pp.(str "Special token " ++ Nameops.pr_id ldots_var ++
    str " is for use in the Notation command.")

let make_current_scope tmp scopes = match tmp, scopes with
| Some tmp_scope, (sc :: _) when String.equal sc tmp_scope -> scopes
| Some tmp_scope, scopes -> tmp_scope :: scopes
| None, scopes -> scopes

let pr_scope_stack = let open Pp in function
  | [] -> str "the empty scope stack"
  | [a] -> str "scope " ++ str a
  | l -> str "scope stack " ++
      str "[" ++ prlist_with_sep pr_comma str l ++ str "]"

let error_inconsistent_scope ?loc id scopes1 scopes2 =
  CErrors.user_err ?loc ~hdr:"set_var_scope"
   Pp.(Nameops.pr_id id ++ str " is here used in " ++
    pr_scope_stack scopes2 ++ strbrk " while it was elsewhere used in " ++
    pr_scope_stack scopes1)

let error_expect_binder_notation_type ?loc id =
  CErrors.user_err ?loc 
   Pp.(Nameops.pr_id id ++
    str " is expected to occur in binding position in the right-hand side.")

let set_var_scope loc id istermvar env ntnvars =
  try
    let isonlybinding,idscopes,typ = Id.Map.find id ntnvars in
    if istermvar then isonlybinding := false;
    let () = if istermvar then
      (* scopes have no effect on the interpretation of identifiers *)
      begin match !idscopes with
      | None -> idscopes := Some (env.tmp_scope, env.scopes)
      | Some (tmp, scope) ->
        let s1 = make_current_scope tmp scope in
        let s2 = make_current_scope env.tmp_scope env.scopes in
        if not (CList.equal String.equal s1 s2) then error_inconsistent_scope ~loc id s1 s2
      end
    in
    match typ with
    | NtnInternTypeBinder ->
	if istermvar then error_expect_binder_notation_type ~loc id
    | NtnInternTypeConstr ->
	(* We need sometimes to parse idents at a constr level for
	   factorization and we cannot enforce this constraint:
	   if not istermvar then error_expect_constr_notation_type loc id *)
	()
    | NtnInternTypeIdent -> ()
  with Not_found ->
    (* Not in a notation *)
    ()

let push_name_env ?(global_level=false) ntnvars implargs env =
  function
  | loc,Anonymous ->
      if global_level then
	CErrors.user_err ~loc Pp.(str "Anonymous variables not allowed");
      env
  | loc,Name id ->
      if Id.Map.is_empty ntnvars && Id.equal id ldots_var
        then error_ldots_var ~loc;
      set_var_scope loc id false env ntnvars;
      if global_level then Dumpglob.dump_definition (loc,id) true "var"
      else Dumpglob.dump_binding loc id;
      {env with ids = Id.Set.add id env.ids; impls = Id.Map.add id implargs env.impls}

let intern_generalized_binder ?(global_level=false) intern_type lvar
    env (loc, na) b b' t ty =
  let ids = (match na with Anonymous -> fun x -> x | Name na -> Id.Set.add na) env.ids in
  let ty, ids' =
    if t then ty, ids else
      Implicit_quantifiers.implicit_application ids
	Implicit_quantifiers.combine_params_freevar ty
  in
  let ty' = intern_type {env with ids = ids; unb = true} ty in
  let fvs = Implicit_quantifiers.generalizable_vars_of_glob_constr ~bound:ids ~allowed:ids' ty' in
  let env' = List.fold_left
    (fun env (x, l) -> push_name_env ~global_level lvar [] env (l, Name x))
    env fvs in
  let bl = List.map
    (fun (id, loc) ->
      (loc, (Name id, b, CHole (loc, Some (Evar_kinds.BinderType (Name id)), Misctypes.IntroAnonymous, None))))
    fvs
  in
  let na = match na with
    | Anonymous ->
	if global_level then na
	else
	  let name =
	    let id =
	      match ty with
	      | CApp (_, (_, CRef (Ident (loc,id),_)), _) -> id
	      | _ -> Namegen.default_non_dependent_ident
	    in Implicit_quantifiers.make_fresh ids' (Global.env ()) id
	  in Name name
    | _ -> na
  in (push_name_env ~global_level lvar (impls_type_list ty')(*?*) env' (loc,na)), (loc,(na,b',ty')) :: List.rev bl

let intern_assumption intern lvar env nal bk ty =
  let intern_type env = intern (set_type_scope env) in
  match bk with
  | Default k ->
      let ty = intern_type env ty in
      check_capture ty nal;
      let impls = impls_type_list ty in
      List.fold_left
	(fun (env, bl) (loc, na as locna) ->
          (push_name_env lvar impls env locna,
           (loc,(na,k,locate_if_hole loc na ty))::bl))
	(env, []) nal
  | Generalized (b,b',t) ->
     let env, b = intern_generalized_binder intern_type lvar env (List.hd nal) b b' t ty in
     env, b

let not_intern_cases_pattern_fwd = ref (fun _ -> failwith "not_intern_cases_pattern_fwd")

let not_intern_local_binder_aux ?(global_level=false) intern lvar (env,bl) =
  function
  | CLocalAssum(nal,bk,ty) ->
      let env, bl' = intern_assumption intern lvar env nal bk ty in
      let bl' = List.map (fun (loc,(na,c,t)) -> CLocalAssum (nal,c,t)) bl' in
      env, bl' @ bl
  | CLocalDef((loc,na as locna),def,ty) ->
     let term = intern env def in
     let ty = Option.map (intern env) ty in
      (push_name_env lvar (impls_term_list term) env locna,
       CLocalDef ((loc,na),term,ty) :: bl)
  | CLocalPattern (loc,p,ty) ->
      let tyc =
        match ty with
        | Some ty -> ty
        | None -> CHole(loc,None,Misctypes.IntroAnonymous,None)
      in
      let il,cp =
        match !not_intern_cases_pattern_fwd (None,env.scopes) p with
        | (il, [(subst,cp)]) ->
           if not (Id.Map.equal Id.equal subst Id.Map.empty) then
             CErrors.user_err ~loc Pp.(str "Unsupported nested \"as\" clause.");
           il,cp
        | _ -> assert false
      in
      let env = {env with ids = List.fold_right Id.Set.add il env.ids} in
      let ienv = Id.Set.elements env.ids in
      let id = Namegen.next_ident_away (Id.of_string "pat") ienv in
      let na = (loc, Name id) in
      let bk = Default Decl_kinds.Explicit in
      let _, bl' = intern_assumption intern lvar env [na] bk tyc in
      let _,(_,bk,t) = List.hd bl' in
      (env, CLocalPattern(loc,(cp,il),id,bk,t) :: bl)

(******************************************************************************)
(* End Duplicated XXX                                                             *)
(******************************************************************************)

let instantiate_notation_constr loc intern ntnvars subst infos c : Constrexpr.constr_expr =
  let (terms,termlists,binders) = subst in
  (* when called while defining a notation, avoid capturing the private binders
     of the expression by variables bound by the notation (see #3892) *)
  let avoid = Id.Map.domain ntnvars in
  let rec aux (terms,binderopt,terminopt as subst') (renaming,env) c : Constrexpr.constr_expr =
    let subinfos = renaming,{env with tmp_scope = None} in
    match c with
    | NVar id when Id.equal id ldots_var -> Option.get terminopt
    | NVar id -> subst_var subst' (renaming, env) id
    | NList (x,y,iter,terminator,lassoc) ->
      let l,(scopt,subscopes) =
        (* All elements of the list are in scopes (scopt,subscopes) *)
        try
          let l,scopes = Id.Map.find x termlists in
          (if lassoc then List.rev l else l),scopes
        with Not_found ->
        try
	  let (bl,(scopt,subscopes)) = Id.Map.find x binders in
	  let env,bl' = List.fold_left (not_intern_local_binder_aux intern ntnvars) (env,[]) bl in
          terms_of_binders (if lassoc then bl' else List.rev bl'),(None,[])
        with Not_found ->
          CErrors.anomaly Pp.(str "Inconsistent substitution of recursive notation") in
      let termin = aux (terms,None,None) subinfos terminator in
      let fold a t =
        let nterms = Id.Map.add y (a, (scopt, subscopes)) terms in
        aux (nterms,None,Some t) subinfos iter
      in
      List.fold_right fold l termin
    | NHole (knd, naming, arg) ->
      let knd = match knd with
      | Evar_kinds.BinderType (Name id as na) ->
        let na =
          try snd (coerce_to_name (fst (Id.Map.find id terms)))
          with Not_found ->
          try Name (Id.Map.find id renaming)
          with Not_found -> na
        in
        Evar_kinds.BinderType na
      | _ -> knd
      in
      let arg = match arg with
      | None -> None
      | Some arg ->
        (* let mk_env (c, (tmp_scope, subscopes)) = *)
        (*   let nenv = {env with tmp_scope; scopes = subscopes @ env.scopes} in *)
        (*   let gc = intern nenv c in *)
        (*   (gc, Some c) *)
        (* in *)
        (* let bindings = Id.Map.map mk_env terms in *)
        None
        (* XXX: Fix the generic argument stuff *)
        (* Some (Genintern.generic_substitute_notation bindings arg) *)
      in
      (* CHole (loc, Some knd, naming, arg) *)
      CHole (loc, Some knd, naming, arg)
    | NBinderList (x,y,iter,terminator) ->
      (try
        (* All elements of the list are in scopes (scopt,subscopes) *)
	let (bl,(scopt,subscopes)) = Id.Map.find x binders in
	let env,bl = List.fold_left (intern_local_binder_aux intern ntnvars) (env,[]) bl in
	let letins,bl = subordinate_letins [] bl in
        let termin = aux (terms,None,None) (renaming,env) terminator in
	let res = List.fold_left (fun t binder ->
	    aux (terms,Some(y,binder),Some t) subinfos iter)
	  termin bl in
	make_letins letins res
      with Not_found ->
          CErrors.anomaly (Pp.str "Inconsistent substitution of recursive notation"))
    | NProd (Name id, NHole _, c') when option_mem_assoc id binderopt ->
        let a,letins = snd (Option.get binderopt) in
        let e = make_letins letins (aux subst' infos c') in
        let ([loc,na],bk,t) = a in
        CProdN (loc,[[loc,na],bk,t],e)
    | NLambda (Name id,NHole _,c') when option_mem_assoc id binderopt ->
        let a,letins = snd (Option.get binderopt) in
        let ([loc, na],bk,t) = a in
        CLambdaN (loc,[[loc,na],bk,t],make_letins letins (aux subst' infos c'))
    (* Two special cases to keep binder name synchronous with BinderType *)
    | NProd (na,NHole(Evar_kinds.BinderType na',naming,arg),c')
        when Name.equal na na' ->
        let subinfos,na = traverse_binder subst avoid subinfos na in
        (* XXX genarg *)
        let ty = CHole (loc,Some (Evar_kinds.BinderType na),naming,None) in
	CProdN (loc,[[loc, na], Decl_kinds.Explicit,ty],aux subst' subinfos c')
    | NLambda (na,NHole(Evar_kinds.BinderType na',naming,arg),c')
        when Name.equal na na' ->
        let subinfos,na = traverse_binder subst avoid subinfos na in
        (* XXX genarg *)
        let ty = CHole (loc,Some (Evar_kinds.BinderType na),naming,None) in
	CLambdaN (loc,[[loc,na],Decl_kinds.Explicit,ty],aux subst' subinfos c')
    | t ->
      glob_constr_of_notation_constr_with_binders loc
        (traverse_binder subst avoid) (aux subst') subinfos t
  and subst_var (terms, _binderopt, _terminopt) (renaming, env) id : Constrexpr.constr_expr =
    (* subst remembers the delimiters stack in the interpretation *)
    (* of the notations *)
    try
      let (a,(scopt,subscopes)) = Id.Map.find id terms in
      intern {env with tmp_scope = scopt;
                       scopes = subscopes @ env.scopes} a
    with Not_found ->
    try
      CRef (Libnames.Ident(loc, Id.Map.find id renaming), None)
    with Not_found ->
      (* Happens for local notation joint with inductive/fixpoint defs *)
      CRef (Libnames.Ident(loc, id), None)
  in aux (terms,None,None) infos c

let split_by_type ids =
  List.fold_right (fun (x,(scl,typ)) (l1,l2,l3) ->
    match typ with
    | NtnTypeConstr | NtnTypeOnlyBinder -> ((x,scl)::l1,l2,l3)
    | NtnTypeConstrList -> (l1,(x,scl)::l2,l3)
    | NtnTypeBinderList -> (l1,l2,(x,scl)::l3)) ids ([],[],[])

let make_subst ids l =
  let fold accu (id, scl) a = Id.Map.add id (a, scl) accu in
  List.fold_left2 fold Id.Map.empty ids l

let intern_notation not_intern env lvar loc ntn fullargs : Constrexpr.constr_expr =
  let ntn,(args,argslist,bll as fullargs) = contract_notation ntn fullargs in
  let ((ids,c),df) = Notation.interp_notation loc ntn (env.tmp_scope,env.scopes) in
  Dumpglob.dump_notation_location (Topconstr.ntn_loc loc fullargs ntn) ntn df;
  let ids,idsl,idsbl = split_by_type ids in
  let terms = make_subst ids args in
  let termlists = make_subst idsl argslist in
  let binders = make_subst idsbl bll in
  instantiate_notation_constr loc not_intern lvar
    (terms, termlists, binders) (Id.Map.empty, env) c

(** {5 Notation Resolution for Patterns } *)

(** {6 Elementary bricks } *)

let rec simple_adjust_scopes n scopes =
  (* Note: they can be less scopes than arguments but also more scopes *)
  (* than arguments because extra scopes are used in the presence of *)
  (* coercions to funclass *)
  if Int.equal n 0 then [] else match scopes with
  | [] -> None :: simple_adjust_scopes (n-1) []
  | sc::scopes -> sc :: simple_adjust_scopes (n-1) scopes


let find_remaining_scopes pl1 pl2 ref =
  let impls_st = Impargs.implicits_of_global ref in
  let len_pl1 = List.length pl1 in
  let len_pl2 = List.length pl2 in
  let impl_list = if Int.equal len_pl1 0
    then Impargs.select_impargs_size len_pl2 impls_st
    else CList.skipn_at_least len_pl1 (Impargs.select_stronger_impargs impls_st) in
  let allscs = Notation.find_arguments_scope ref in
  let scope_list = CList.skipn_at_least len_pl1 allscs in
  let rec aux = function
    |[],l -> l
    |_,[] -> []
    |h::t,_::tt when Impargs.is_status_implicit h -> aux (t,tt)
    |_::t,h::tt -> h :: aux (t,tt)
  in ((try CList.firstn len_pl1 allscs with Failure _ -> simple_adjust_scopes len_pl1 allscs),
      simple_adjust_scopes len_pl2 (aux (impl_list,scope_list)))

(** {6 Main Routine for Notation Expansion }

    @returns a raw_case_pattern_expr :
    - no notations and syntactic definition
    - global reference and identifeir instead of reference

*)
let drop_notations_pattern looked_for =
  (* At toplevel, Constructors and Inductives are accepted, in recursive calls
     only constructor are allowed *)
  let ensure_kind top loc g =
    try
      if top then looked_for g else
      match g with ConstructRef _ -> () | _ -> raise Not_found
    with Not_found ->
      Topconstr.error_invalid_pattern_notation ~loc ()
  in
  let test_kind top =
    if top then looked_for else function ConstructRef _ -> () | _ -> raise Not_found
  in
  (** [rcp_of_glob] : from [glob_constr] to [raw_cases_pattern_expr] *)
  let rec rcp_of_glob = let open Glob_term in function
    | GVar (loc,id) -> RCPatAtom (loc,Some id)
    | GHole (loc,_,_,_) -> RCPatAtom (loc,None)
    | GRef (loc,g,_) -> RCPatCstr (loc, g,[],[])
    | GApp (loc,GRef (_,g,_),l) -> RCPatCstr (loc, g, List.map rcp_of_glob l,[])
    | _ -> CErrors.anomaly Pp.(str "Invalid return pattern from Notation.interp_prim_token_cases_pattern_expr ")
  in
  let rec drop_syndef top scopes re pats =
    let (loc,qid) = qualid_of_reference re in
    try
      match Nametab.locate_extended qid with
      | SynDef sp ->
	let (vars,a) = Syntax_def.search_syntactic_definition sp in
	(match a with
	| NRef g ->
          (* Convention: do not deactivate implicit arguments and scopes for further arguments *)
	  test_kind top g;
	  let () = assert (CList.is_empty vars) in
	  let (_,argscs) = find_remaining_scopes [] pats g in
	  Some (g, [], List.map2 (in_pat_sc scopes) argscs pats)
	| NApp (NRef g,[]) -> (* special case: Syndef for @Cstr, this deactivates *)
	      test_kind top g;
              let () = assert (CList.is_empty vars) in
	      Some (g, List.map (in_pat false scopes) pats, [])
	| NApp (NRef g,args) ->
              (* Convention: do not deactivate implicit arguments and scopes for further arguments *)
	      test_kind top g;
	      let nvars = List.length vars in
	      if List.length pats < nvars then error_not_enough_arguments loc;
	      let pats1,pats2 = CList.chop nvars pats in
	      let subst = make_subst vars pats1 in
	      let idspl1 = List.map (in_not false loc scopes (subst, Id.Map.empty) []) args in
	      let (_,argscs) = find_remaining_scopes pats1 pats2 g in
	      Some (g, idspl1, List.map2 (in_pat_sc scopes) argscs pats2)
	| _ -> raise Not_found)
      | TrueGlobal g ->
	  test_kind top g;
	  Dumpglob.add_glob loc g;
	  let (_,argscs) = find_remaining_scopes [] pats g in
	  Some (g,[],List.map2 (fun x -> in_pat false (x,snd scopes)) argscs pats)
    with Not_found -> None
  and in_pat top scopes = function
    | CPatAlias (loc, p, id) -> RCPatAlias (loc, in_pat top scopes p, id)
    | CPatRecord (loc, l) ->
      let sorted_fields =
	sort_fields ~complete:false loc l (fun _idx -> (CPatAtom (loc, None))) in
      begin match sorted_fields with
	| None -> RCPatAtom (loc, None)
	| Some (n, head, pl) ->
          let pl =
            if !Topconstr.asymmetric_patterns then pl else
            let pars = CList.make n (CPatAtom (loc, None)) in
            List.rev_append pars pl in
	  match drop_syndef top scopes head pl with
	    |Some (a,b,c) -> RCPatCstr(loc, a, b, c)
	    |None -> raise (NotationResolutionError (loc,NotAConstructor head))
      end
    | CPatCstr (loc, head, None, pl) ->
      begin
	match drop_syndef top scopes head pl with
	  | Some (a,b,c) -> RCPatCstr(loc, a, b, c)
	  | None -> raise (NotationResolutionError (loc,NotAConstructor head))
      end
     | CPatCstr (loc, r, Some expl_pl, pl) ->
       let g = try Nametab.locate (snd (qualid_of_reference r))
	      with Not_found ->
 	      raise (NotationResolutionError (loc,NotAConstructor r)) in
       if expl_pl == [] then
       (* Convention: (@r) deactivates all further implicit arguments and scopes *)
       RCPatCstr (loc, g, List.map (in_pat false scopes) pl, [])
      else
        (* Convention: (@r expl_pl) deactivates implicit arguments in expl_pl and in pl *)
        (* but not scopes in expl_pl *)
        let (argscs1,_) = find_remaining_scopes expl_pl pl g in
        RCPatCstr (loc, g, List.map2 (in_pat_sc scopes) argscs1 expl_pl @ List.map (in_pat false scopes) pl, [])
    | CPatNotation (loc,"- _",([CPatPrim(_,Numeral p)],[]),[])
      when Bigint.is_strictly_pos p ->
      let (pat, _df) = Notation.interp_prim_token_cases_pattern_expr loc (ensure_kind false loc) (Numeral (Bigint.neg p)) scopes in
      rcp_of_glob pat
    | CPatNotation (_,"( _ )",([a],[]),[]) ->
      in_pat top scopes a
    | CPatNotation (loc, ntn, fullargs,extrargs) ->
      let ntn,(args,argsl as fullargs) = contract_pat_notation ntn fullargs in
      let ((ids',c),df) = Notation.interp_notation loc ntn scopes in
      let (ids',idsl',_) = split_by_type ids' in
      Dumpglob.dump_notation_location (Topconstr.patntn_loc loc fullargs ntn) ntn df;
      let substlist = make_subst idsl' argsl in
      let subst = make_subst ids' args in
      in_not top loc scopes (subst,substlist) extrargs c
    | CPatDelimiters (loc, key, e) ->
      in_pat top (None,Notation.find_delimiters_scope loc key::snd scopes) e
    | CPatPrim (loc,p) ->
      let (pat, _df) = Notation.interp_prim_token_cases_pattern_expr loc (test_kind false) p scopes in
      rcp_of_glob pat
    | CPatAtom (loc, Some id) ->
      begin
	match drop_syndef top scopes id [] with
	  |Some (a,b,c) -> RCPatCstr (loc, a, b, c)
	  |None -> RCPatAtom (loc, Some (find_pattern_variable id))
      end
    | CPatAtom (loc,None) -> RCPatAtom (loc,None)
    | CPatOr (loc, pl) ->
      RCPatOr (loc,List.map (in_pat top scopes) pl)
    | CPatCast (loc,_,_) ->
      (* We raise an error if the pattern contains a cast, due to
         current restrictions on casts in patterns. Cast in patterns
         are supportted only in local binders and only at top
         level. In fact, they are currently eliminated by the
         parser. The only reason why they are in the
         [cases_pattern_expr] type is that the parser needs to factor
         the "(c : t)" notation with user defined notations (such as
         the pair). In the long term, we will try to support such
         casts everywhere, and use them to print the domains of
         lambdas in the encoding of match in constr. This check is
         here and not in the parser because it would require to
         duplicate the levels of the [pattern] rule. *)
      CErrors.user_err ~loc ~hdr:"drop_notations_pattern"
                            (Pp.strbrk "Casts are not supported in this pattern.")
  and in_pat_sc scopes x = in_pat false (x,snd scopes)
  and in_not top loc scopes (subst,substlist as fullsubst) args = function
    | NVar id ->
      let () = assert (CList.is_empty args) in
      begin
	(* subst remembers the delimiters stack in the interpretation *)
	(* of the notations *)
	try
	  let (a,(scopt,subscopes)) = Id.Map.find id subst in
	  in_pat top (scopt,subscopes@snd scopes) a
	with Not_found ->
	  if Id.equal id ldots_var then RCPatAtom (loc,Some id) else
	    CErrors.anomaly Pp.(str "Unbound pattern notation variable: " ++ Id.print id)
      end
    | NRef g ->
      ensure_kind top loc g;
      let (_,argscs) = find_remaining_scopes [] args g in
      RCPatCstr (loc, g, [], List.map2 (in_pat_sc scopes) argscs args)
    | NApp (NRef g,pl) ->
      ensure_kind top loc g;
      let (argscs1,argscs2) = find_remaining_scopes pl args g in
      RCPatCstr (loc, g,
		 List.map2 (fun x -> in_not false loc (x,snd scopes) fullsubst []) argscs1 pl @
		 List.map (in_pat false scopes) args, [])
    | NList (x,y,iter,terminator,lassoc) ->
      if not (CList.is_empty args) then CErrors.user_err ~loc 
        Pp.(strbrk "Application of arguments to a recursive notation not supported in patterns.");
      (try
         (* All elements of the list are in scopes (scopt,subscopes) *)
	 let (l,(scopt,subscopes)) = Id.Map.find x substlist in
         let termin = in_not top loc scopes fullsubst [] terminator in
	 List.fold_right (fun a t ->
           let nsubst = Id.Map.add y (a, (scopt, subscopes)) subst in
           let u = in_not false loc scopes (nsubst, substlist) [] iter in
           subst_pat_iterator ldots_var t u)
           (if lassoc then List.rev l else l) termin
       with Not_found ->
         CErrors.anomaly Pp.(str "Inconsistent substitution of recursive notation"))
    | NHole _ ->
      let () = assert (CList.is_empty args) in
      RCPatAtom (loc, None)
    | t -> Topconstr.error_invalid_pattern_notation ~loc ()
  in in_pat true

let drop_notations_pattern ~inductive_pattern scopes pat =
  if inductive_pattern then
    try drop_notations_pattern (function (IndRef _ | ConstructRef _) -> () | _ -> raise Not_found) scopes pat
    with NotationResolutionError(loc, NotAConstructor _) -> error_bad_inductive_type ~loc
  else
    try drop_notations_pattern (function ConstructRef _ -> () | _ -> raise Not_found) scopes pat
    with NotationResolutionError (loc,e) ->
      CErrors.user_err ~loc ~hdr:"internalize" (explain_notation_resolution_error e)

(** { 5 Notation Resolution Pass *)

let rec resolve_notation ntnvars env (ce : constr_expr) = match ce with
  | CRef (_,_) as ce -> ce
  | CFix (loc,ids,fbody) -> ce
  | CCoFix (_,_,_) -> ce
  | CProdN (_,_,_) -> ce
  | CLambdaN (_,_,_) -> ce
  | CLetIn (_,_,_,_,_) -> ce
  | CAppExpl (_,_,_) -> ce
  | CApp (_,_,_) -> ce
  | CCases (_,_,_,_,_) -> ce
  | CLetTuple (_,_,_,_,_) -> ce
  | CIf (_,_,_,_,_) -> ce
  | CHole (_,_,_,_) -> ce
  | CPatVar (_,_) -> ce
  | CEvar (_,_,_) -> ce
  | CSort (_,_) -> ce
  | CCast (_,_,_) -> ce
  | CGeneralization (_,_,_,_) -> ce

  | CRecord (loc, fs) ->
    let st = Evar_kinds.Define (not (Program.get_proofs_transparency ())) in
    let fields =
      sort_fields ~complete:true loc fs
	(fun _idx -> CHole (loc, Some (Evar_kinds.QuestionMark st),
                     Misctypes.IntroAnonymous, None))
    in
    begin
      match fields with
      | None -> CErrors.user_err ~loc ~hdr:"intern" Pp.(str"No constructor inference.")
      | Some (n, constrname, args) ->
        let pars = CList.make n (CHole (loc, None, Misctypes.IntroAnonymous, None)) in
        let app = CAppExpl (loc, (None, constrname,None), List.rev_append pars args) in
        resolve_notation ntnvars env app
    end

  | CDelimiters (loc, key, e) ->
    resolve_notation ntnvars {env with tmp_scope = None;
                                       scopes = Notation.find_delimiters_scope loc key :: env.scopes} e

  | CPrim (loc, p) ->
    (* XXX: *)
    let ist = fst (Notation.interp_prim_token loc p (env.tmp_scope,env.scopes)) in
    Constrextern.extern_glob_constr Names.Id.Set.empty ist

  | CNotation (_,"( _ )",([a],[],[])) -> resolve_notation ntnvars env a

  | CNotation (loc,"- _",([CPrim (_,Numeral p)],[],[]))
    when Bigint.is_strictly_pos p ->
    CPrim (loc,Numeral (Bigint.neg p))

  | CNotation (loc,ntn,args) ->
    intern_notation resolve_notation env ntnvars loc ntn args

